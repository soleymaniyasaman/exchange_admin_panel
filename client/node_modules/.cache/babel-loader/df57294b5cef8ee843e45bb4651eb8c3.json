{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * The inline autoformatting engine. It allows to format various inline patterns. For example,\n * it can be configured to make \"foo\" bold when typed `**foo**` (the `**` markers will be removed).\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the {@link module:autoformat/inlineautoformatediting~inlineAutoformatEditing `inlineAutoformatEditing`} documentation\n * to learn how to create custom inline autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n *\n * @module autoformat/inlineautoformatediting\n */\n\n/**\n * Enables autoformatting mechanism for a given {@link module:core/editor/editor~Editor}.\n *\n * It formats the matched text by applying the given model attribute or by running the provided formatting callback.\n * On every {@link module:engine/model/document~Document#event:change:data data change} in the model document\n * the autoformatting engine checks the text on the left of the selection\n * and executes the provided action if the text matches given criteria (regular expression or callback).\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n * @param {module:autoformat/autoformat~Autoformat} plugin The autoformat plugin instance.\n * @param {Function|RegExp} testRegexpOrCallback The regular expression or callback to execute on text.\n * Provided regular expression *must* have three capture groups. The first and the third capture group\n * should match opening and closing delimiters. The second capture group should match the text to format.\n *\n *\t\t// Matches the `**bold text**` pattern.\n *\t\t// There are three capturing groups:\n *\t\t// - The first to match the starting `**` delimiter.\n *\t\t// - The second to match the text to format.\n *\t\t// - The third to match the ending `**` delimiter.\n *\t\tinlineAutoformatEditing( editor, plugin, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, formatCallback );\n *\n * When a function is provided instead of the regular expression, it will be executed with the text to match as a parameter.\n * The function should return proper \"ranges\" to delete and format.\n *\n *\t\t{\n *\t\t\tremove: [\n *\t\t\t\t[ 0, 1 ],\t// Remove the first letter from the given text.\n *\t\t\t\t[ 5, 6 ]\t// Remove the 6th letter from the given text.\n *\t\t\t],\n *\t\t\tformat: [\n *\t\t\t\t[ 1, 5 ]\t// Format all letters from 2nd to 5th.\n *\t\t\t]\n *\t\t}\n *\n * @param {Function} formatCallback A callback to apply actual formatting.\n * It should return `false` if changes should not be applied (e.g. if a command is disabled).\n *\n *\t\tinlineAutoformatEditing( editor, plugin, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, ( writer, rangesToFormat ) => {\n *\t\t\tconst command = editor.commands.get( 'bold' );\n *\n *\t\t\tif ( !command.isEnabled ) {\n *\t\t\t\treturn false;\n *\t\t\t}\n *\n *\t\t\tconst validRanges = editor.model.schema.getValidRanges( rangesToFormat, 'bold' );\n *\n *\t\t\tfor ( let range of validRanges ) {\n *\t\t\t\twriter.setAttribute( 'bold', true, range );\n *\t\t\t}\n *\t\t} );\n */\nexport default function inlineAutoformatEditing(editor, plugin, testRegexpOrCallback, formatCallback) {\n  let regExp;\n  let testCallback;\n\n  if (testRegexpOrCallback instanceof RegExp) {\n    regExp = testRegexpOrCallback;\n  } else {\n    testCallback = testRegexpOrCallback;\n  } // A test callback run on changed text.\n\n\n  testCallback = testCallback || (text => {\n    let result;\n    const remove = [];\n    const format = [];\n\n    while ((result = regExp.exec(text)) !== null) {\n      // There should be full match and 3 capture groups.\n      if (result && result.length < 4) {\n        break;\n      }\n\n      let {\n        index,\n        '1': leftDel,\n        '2': content,\n        '3': rightDel\n      } = result; // Real matched string - there might be some non-capturing groups so we need to recalculate starting index.\n\n      const found = leftDel + content + rightDel;\n      index += result[0].length - found.length; // Start and End offsets of delimiters to remove.\n\n      const delStart = [index, index + leftDel.length];\n      const delEnd = [index + leftDel.length + content.length, index + leftDel.length + content.length + rightDel.length];\n      remove.push(delStart);\n      remove.push(delEnd);\n      format.push([index + leftDel.length, index + leftDel.length + content.length]);\n    }\n\n    return {\n      remove,\n      format\n    };\n  });\n\n  editor.model.document.on('change:data', (evt, batch) => {\n    if (batch.type == 'transparent' || !plugin.isEnabled) {\n      return;\n    }\n\n    const model = editor.model;\n    const selection = model.document.selection; // Do nothing if selection is not collapsed.\n\n    if (!selection.isCollapsed) {\n      return;\n    }\n\n    const changes = Array.from(model.document.differ.getChanges());\n    const entry = changes[0]; // Typing is represented by only a single change.\n\n    if (changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1) {\n      return;\n    }\n\n    const focus = selection.focus;\n    const block = focus.parent;\n    const {\n      text,\n      range\n    } = getTextAfterCode(model.createRange(model.createPositionAt(block, 0), focus), model);\n    const testOutput = testCallback(text);\n    const rangesToFormat = testOutputToRanges(range.start, testOutput.format, model);\n    const rangesToRemove = testOutputToRanges(range.start, testOutput.remove, model);\n\n    if (!(rangesToFormat.length && rangesToRemove.length)) {\n      return;\n    } // Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n\n\n    model.enqueueChange(writer => {\n      // Apply format.\n      const hasChanged = formatCallback(writer, rangesToFormat); // Strict check on `false` to have backward compatibility (when callbacks were returning `undefined`).\n\n      if (hasChanged === false) {\n        return;\n      } // Remove delimiters - use reversed order to not mix the offsets while removing.\n\n\n      for (const range of rangesToRemove.reverse()) {\n        writer.remove(range);\n      }\n\n      model.enqueueChange(() => {\n        editor.plugins.get('Delete').requestUndoOnBackspace();\n      });\n    });\n  });\n} // Converts output of the test function provided to the inlineAutoformatEditing and converts it to the model ranges\n// inside provided block.\n//\n// @private\n// @param {module:engine/model/position~Position} start\n// @param {Array.<Array>} arrays\n// @param {module:engine/model/model~Model} model\n\nfunction testOutputToRanges(start, arrays, model) {\n  return arrays.filter(array => array[0] !== undefined && array[1] !== undefined).map(array => {\n    return model.createRange(start.getShiftedBy(array[0]), start.getShiftedBy(array[1]));\n  });\n} // Returns the last text line after the last code element from the given range.\n// It is similar to {@link module:typing/utils/getlasttextline.getLastTextLine `getLastTextLine()`},\n// but it ignores any text before the last `code`.\n//\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/model~Model} model\n// @returns {module:typing/utils/getlasttextline~LastTextLineData}\n\n\nfunction getTextAfterCode(range, model) {\n  let start = range.start;\n  const text = Array.from(range.getItems()).reduce((rangeText, node) => {\n    // Trim text to a last occurrence of an inline element and update range start.\n    if (!(node.is('$text') || node.is('$textProxy')) || node.getAttribute('code')) {\n      start = model.createPositionAfter(node);\n      return '';\n    }\n\n    return rangeText + node.data;\n  }, '');\n  return {\n    text,\n    range: model.createRange(start, range.end)\n  };\n}","map":{"version":3,"sources":["/Users/yasaman/Documents/moj_adminpanel/adminpanel/node_modules/@ckeditor/ckeditor5-autoformat/src/inlineautoformatediting.js"],"names":["inlineAutoformatEditing","editor","plugin","testRegexpOrCallback","formatCallback","regExp","testCallback","RegExp","text","result","remove","format","exec","length","index","leftDel","content","rightDel","found","delStart","delEnd","push","model","document","on","evt","batch","type","isEnabled","selection","isCollapsed","changes","Array","from","differ","getChanges","entry","name","focus","block","parent","range","getTextAfterCode","createRange","createPositionAt","testOutput","rangesToFormat","testOutputToRanges","start","rangesToRemove","enqueueChange","writer","hasChanged","reverse","plugins","get","requestUndoOnBackspace","arrays","filter","array","undefined","map","getShiftedBy","getItems","reduce","rangeText","node","is","getAttribute","createPositionAfter","data","end"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * The inline autoformatting engine. It allows to format various inline patterns. For example,\n * it can be configured to make \"foo\" bold when typed `**foo**` (the `**` markers will be removed).\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the {@link module:autoformat/inlineautoformatediting~inlineAutoformatEditing `inlineAutoformatEditing`} documentation\n * to learn how to create custom inline autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n *\n * @module autoformat/inlineautoformatediting\n */\n\n/**\n * Enables autoformatting mechanism for a given {@link module:core/editor/editor~Editor}.\n *\n * It formats the matched text by applying the given model attribute or by running the provided formatting callback.\n * On every {@link module:engine/model/document~Document#event:change:data data change} in the model document\n * the autoformatting engine checks the text on the left of the selection\n * and executes the provided action if the text matches given criteria (regular expression or callback).\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n * @param {module:autoformat/autoformat~Autoformat} plugin The autoformat plugin instance.\n * @param {Function|RegExp} testRegexpOrCallback The regular expression or callback to execute on text.\n * Provided regular expression *must* have three capture groups. The first and the third capture group\n * should match opening and closing delimiters. The second capture group should match the text to format.\n *\n *\t\t// Matches the `**bold text**` pattern.\n *\t\t// There are three capturing groups:\n *\t\t// - The first to match the starting `**` delimiter.\n *\t\t// - The second to match the text to format.\n *\t\t// - The third to match the ending `**` delimiter.\n *\t\tinlineAutoformatEditing( editor, plugin, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, formatCallback );\n *\n * When a function is provided instead of the regular expression, it will be executed with the text to match as a parameter.\n * The function should return proper \"ranges\" to delete and format.\n *\n *\t\t{\n *\t\t\tremove: [\n *\t\t\t\t[ 0, 1 ],\t// Remove the first letter from the given text.\n *\t\t\t\t[ 5, 6 ]\t// Remove the 6th letter from the given text.\n *\t\t\t],\n *\t\t\tformat: [\n *\t\t\t\t[ 1, 5 ]\t// Format all letters from 2nd to 5th.\n *\t\t\t]\n *\t\t}\n *\n * @param {Function} formatCallback A callback to apply actual formatting.\n * It should return `false` if changes should not be applied (e.g. if a command is disabled).\n *\n *\t\tinlineAutoformatEditing( editor, plugin, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, ( writer, rangesToFormat ) => {\n *\t\t\tconst command = editor.commands.get( 'bold' );\n *\n *\t\t\tif ( !command.isEnabled ) {\n *\t\t\t\treturn false;\n *\t\t\t}\n *\n *\t\t\tconst validRanges = editor.model.schema.getValidRanges( rangesToFormat, 'bold' );\n *\n *\t\t\tfor ( let range of validRanges ) {\n *\t\t\t\twriter.setAttribute( 'bold', true, range );\n *\t\t\t}\n *\t\t} );\n */\nexport default function inlineAutoformatEditing( editor, plugin, testRegexpOrCallback, formatCallback ) {\n\tlet regExp;\n\tlet testCallback;\n\n\tif ( testRegexpOrCallback instanceof RegExp ) {\n\t\tregExp = testRegexpOrCallback;\n\t} else {\n\t\ttestCallback = testRegexpOrCallback;\n\t}\n\n\t// A test callback run on changed text.\n\ttestCallback = testCallback || ( text => {\n\t\tlet result;\n\t\tconst remove = [];\n\t\tconst format = [];\n\n\t\twhile ( ( result = regExp.exec( text ) ) !== null ) {\n\t\t\t// There should be full match and 3 capture groups.\n\t\t\tif ( result && result.length < 4 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet {\n\t\t\t\tindex,\n\t\t\t\t'1': leftDel,\n\t\t\t\t'2': content,\n\t\t\t\t'3': rightDel\n\t\t\t} = result;\n\n\t\t\t// Real matched string - there might be some non-capturing groups so we need to recalculate starting index.\n\t\t\tconst found = leftDel + content + rightDel;\n\t\t\tindex += result[ 0 ].length - found.length;\n\n\t\t\t// Start and End offsets of delimiters to remove.\n\t\t\tconst delStart = [\n\t\t\t\tindex,\n\t\t\t\tindex + leftDel.length\n\t\t\t];\n\t\t\tconst delEnd = [\n\t\t\t\tindex + leftDel.length + content.length,\n\t\t\t\tindex + leftDel.length + content.length + rightDel.length\n\t\t\t];\n\n\t\t\tremove.push( delStart );\n\t\t\tremove.push( delEnd );\n\n\t\t\tformat.push( [ index + leftDel.length, index + leftDel.length + content.length ] );\n\t\t}\n\n\t\treturn {\n\t\t\tremove,\n\t\t\tformat\n\t\t};\n\t} );\n\n\teditor.model.document.on( 'change:data', ( evt, batch ) => {\n\t\tif ( batch.type == 'transparent' || !plugin.isEnabled ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst model = editor.model;\n\t\tconst selection = model.document.selection;\n\n\t\t// Do nothing if selection is not collapsed.\n\t\tif ( !selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst changes = Array.from( model.document.differ.getChanges() );\n\t\tconst entry = changes[ 0 ];\n\n\t\t// Typing is represented by only a single change.\n\t\tif ( changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst focus = selection.focus;\n\t\tconst block = focus.parent;\n\t\tconst { text, range } = getTextAfterCode( model.createRange( model.createPositionAt( block, 0 ), focus ), model );\n\t\tconst testOutput = testCallback( text );\n\t\tconst rangesToFormat = testOutputToRanges( range.start, testOutput.format, model );\n\t\tconst rangesToRemove = testOutputToRanges( range.start, testOutput.remove, model );\n\n\t\tif ( !( rangesToFormat.length && rangesToRemove.length ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n\t\tmodel.enqueueChange( writer => {\n\t\t\t// Apply format.\n\t\t\tconst hasChanged = formatCallback( writer, rangesToFormat );\n\n\t\t\t// Strict check on `false` to have backward compatibility (when callbacks were returning `undefined`).\n\t\t\tif ( hasChanged === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Remove delimiters - use reversed order to not mix the offsets while removing.\n\t\t\tfor ( const range of rangesToRemove.reverse() ) {\n\t\t\t\twriter.remove( range );\n\t\t\t}\n\n\t\t\tmodel.enqueueChange( () => {\n\t\t\t\teditor.plugins.get( 'Delete' ).requestUndoOnBackspace();\n\t\t\t} );\n\t\t} );\n\t} );\n}\n\n// Converts output of the test function provided to the inlineAutoformatEditing and converts it to the model ranges\n// inside provided block.\n//\n// @private\n// @param {module:engine/model/position~Position} start\n// @param {Array.<Array>} arrays\n// @param {module:engine/model/model~Model} model\nfunction testOutputToRanges( start, arrays, model ) {\n\treturn arrays\n\t\t.filter( array => ( array[ 0 ] !== undefined && array[ 1 ] !== undefined ) )\n\t\t.map( array => {\n\t\t\treturn model.createRange( start.getShiftedBy( array[ 0 ] ), start.getShiftedBy( array[ 1 ] ) );\n\t\t} );\n}\n\n// Returns the last text line after the last code element from the given range.\n// It is similar to {@link module:typing/utils/getlasttextline.getLastTextLine `getLastTextLine()`},\n// but it ignores any text before the last `code`.\n//\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/model~Model} model\n// @returns {module:typing/utils/getlasttextline~LastTextLineData}\nfunction getTextAfterCode( range, model ) {\n\tlet start = range.start;\n\n\tconst text = Array.from( range.getItems() ).reduce( ( rangeText, node ) => {\n\t\t// Trim text to a last occurrence of an inline element and update range start.\n\t\tif ( !( node.is( '$text' ) || node.is( '$textProxy' ) ) || node.getAttribute( 'code' ) ) {\n\t\t\tstart = model.createPositionAfter( node );\n\n\t\t\treturn '';\n\t\t}\n\n\t\treturn rangeText + node.data;\n\t}, '' );\n\n\treturn { text, range: model.createRange( start, range.end ) };\n}\n"]},"metadata":{},"sourceType":"module"}