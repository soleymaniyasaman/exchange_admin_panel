{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { LiveRange } from 'ckeditor5/src/engine';\nimport { first } from 'ckeditor5/src/utils';\n/**\n * The block autoformatting engine. It allows to format various block patterns. For example,\n * it can be configured to turn a paragraph starting with `*` and followed by a space into a list item.\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the {@link module:autoformat/blockautoformatediting~blockAutoformatEditing `blockAutoformatEditing`} documentation\n * to learn how to create custom block autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n *\n * @module autoformat/blockautoformatediting\n */\n\n/**\n * Creates a listener triggered on {@link module:engine/model/document~Document#event:change:data `change:data`} event in the document.\n * Calls the callback when inserted text matches the regular expression or the command name\n * if provided instead of the callback.\n *\n * Examples of usage:\n *\n * To convert a paragraph to heading 1 when `- ` is typed, using just the command name:\n *\n *\t\tblockAutoformatEditing( editor, plugin, /^\\- $/, 'heading1' );\n *\n * To convert a paragraph to heading 1 when `- ` is typed, using just the callback:\n *\n *\t\tblockAutoformatEditing( editor, plugin, /^\\- $/, ( context ) => {\n *\t\t\tconst { match } = context;\n *\t\t\tconst headingLevel = match[ 1 ].length;\n *\n *\t\t\teditor.execute( 'heading', {\n *\t\t\t\tformatId: `heading${ headingLevel }`\n *\t\t\t} );\n * \t\t} );\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n * @param {module:autoformat/autoformat~Autoformat} plugin The autoformat plugin instance.\n * @param {RegExp} pattern The regular expression to execute on just inserted text. The regular expression is tested against the text\n * from the beginning until the caret position.\n * @param {Function|String} callbackOrCommand The callback to execute or the command to run when the text is matched.\n * In case of providing the callback, it receives the following parameter:\n * * {Object} match RegExp.exec() result of matching the pattern to inserted text.\n */\n\nexport default function blockAutoformatEditing(editor, plugin, pattern, callbackOrCommand) {\n  let callback;\n  let command = null;\n\n  if (typeof callbackOrCommand == 'function') {\n    callback = callbackOrCommand;\n  } else {\n    // We assume that the actual command name was provided.\n    command = editor.commands.get(callbackOrCommand);\n\n    callback = () => {\n      editor.execute(callbackOrCommand);\n    };\n  }\n\n  editor.model.document.on('change:data', (evt, batch) => {\n    if (command && !command.isEnabled || !plugin.isEnabled) {\n      return;\n    }\n\n    const range = first(editor.model.document.selection.getRanges());\n\n    if (!range.isCollapsed) {\n      return;\n    }\n\n    if (batch.type == 'transparent') {\n      return;\n    }\n\n    const changes = Array.from(editor.model.document.differ.getChanges());\n    const entry = changes[0]; // Typing is represented by only a single change.\n\n    if (changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1) {\n      return;\n    }\n\n    const blockToFormat = entry.position.parent; // Block formatting should be disabled in codeBlocks (#5800).\n\n    if (blockToFormat.is('element', 'codeBlock')) {\n      return;\n    } // Only list commands and custom callbacks can be applied inside a list.\n\n\n    if (blockToFormat.is('element', 'listItem') && typeof callbackOrCommand !== 'function' && !['numberedList', 'bulletedList', 'todoList'].includes(callbackOrCommand)) {\n      return;\n    } // In case a command is bound, do not re-execute it over an existing block style which would result with a style removal.\n    // Instead just drop processing so that autoformat trigger text is not lost. E.g. writing \"# \" in a level 1 heading.\n\n\n    if (command && command.value === true) {\n      return;\n    }\n\n    const firstNode = blockToFormat.getChild(0);\n    const firstNodeRange = editor.model.createRangeOn(firstNode); // Range is only expected to be within or at the very end of the first text node.\n\n    if (!firstNodeRange.containsRange(range) && !range.end.isEqual(firstNodeRange.end)) {\n      return;\n    }\n\n    const match = pattern.exec(firstNode.data.substr(0, range.end.offset)); // ...and this text node's data match the pattern.\n\n    if (!match) {\n      return;\n    } // Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n\n\n    editor.model.enqueueChange(writer => {\n      // Matched range.\n      const start = writer.createPositionAt(blockToFormat, 0);\n      const end = writer.createPositionAt(blockToFormat, match[0].length);\n      const range = new LiveRange(start, end);\n      const wasChanged = callback({\n        match\n      }); // Remove matched text.\n\n      if (wasChanged !== false) {\n        writer.remove(range);\n        const selectionRange = editor.model.document.selection.getFirstRange();\n        const blockRange = writer.createRangeIn(blockToFormat); // If the block is empty and the document selection has been moved when\n        // applying formatting (e.g. is now in newly created block).\n\n        if (blockToFormat.isEmpty && !blockRange.isEqual(selectionRange) && !blockRange.containsRange(selectionRange, true)) {\n          writer.remove(blockToFormat);\n        }\n      }\n\n      range.detach();\n      editor.model.enqueueChange(() => {\n        editor.plugins.get('Delete').requestUndoOnBackspace();\n      });\n    });\n  });\n}","map":{"version":3,"sources":["/Users/yasaman/Documents/moj_adminpanel/adminpanel/node_modules/@ckeditor/ckeditor5-autoformat/src/blockautoformatediting.js"],"names":["LiveRange","first","blockAutoformatEditing","editor","plugin","pattern","callbackOrCommand","callback","command","commands","get","execute","model","document","on","evt","batch","isEnabled","range","selection","getRanges","isCollapsed","type","changes","Array","from","differ","getChanges","entry","length","name","blockToFormat","position","parent","is","includes","value","firstNode","getChild","firstNodeRange","createRangeOn","containsRange","end","isEqual","match","exec","data","substr","offset","enqueueChange","writer","start","createPositionAt","wasChanged","remove","selectionRange","getFirstRange","blockRange","createRangeIn","isEmpty","detach","plugins","requestUndoOnBackspace"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport { LiveRange } from 'ckeditor5/src/engine';\nimport { first } from 'ckeditor5/src/utils';\n\n/**\n * The block autoformatting engine. It allows to format various block patterns. For example,\n * it can be configured to turn a paragraph starting with `*` and followed by a space into a list item.\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the {@link module:autoformat/blockautoformatediting~blockAutoformatEditing `blockAutoformatEditing`} documentation\n * to learn how to create custom block autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n *\n * @module autoformat/blockautoformatediting\n */\n\n/**\n * Creates a listener triggered on {@link module:engine/model/document~Document#event:change:data `change:data`} event in the document.\n * Calls the callback when inserted text matches the regular expression or the command name\n * if provided instead of the callback.\n *\n * Examples of usage:\n *\n * To convert a paragraph to heading 1 when `- ` is typed, using just the command name:\n *\n *\t\tblockAutoformatEditing( editor, plugin, /^\\- $/, 'heading1' );\n *\n * To convert a paragraph to heading 1 when `- ` is typed, using just the callback:\n *\n *\t\tblockAutoformatEditing( editor, plugin, /^\\- $/, ( context ) => {\n *\t\t\tconst { match } = context;\n *\t\t\tconst headingLevel = match[ 1 ].length;\n *\n *\t\t\teditor.execute( 'heading', {\n *\t\t\t\tformatId: `heading${ headingLevel }`\n *\t\t\t} );\n * \t\t} );\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n * @param {module:autoformat/autoformat~Autoformat} plugin The autoformat plugin instance.\n * @param {RegExp} pattern The regular expression to execute on just inserted text. The regular expression is tested against the text\n * from the beginning until the caret position.\n * @param {Function|String} callbackOrCommand The callback to execute or the command to run when the text is matched.\n * In case of providing the callback, it receives the following parameter:\n * * {Object} match RegExp.exec() result of matching the pattern to inserted text.\n */\nexport default function blockAutoformatEditing( editor, plugin, pattern, callbackOrCommand ) {\n\tlet callback;\n\tlet command = null;\n\n\tif ( typeof callbackOrCommand == 'function' ) {\n\t\tcallback = callbackOrCommand;\n\t} else {\n\t\t// We assume that the actual command name was provided.\n\t\tcommand = editor.commands.get( callbackOrCommand );\n\n\t\tcallback = () => {\n\t\t\teditor.execute( callbackOrCommand );\n\t\t};\n\t}\n\n\teditor.model.document.on( 'change:data', ( evt, batch ) => {\n\t\tif ( command && !command.isEnabled || !plugin.isEnabled ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst range = first( editor.model.document.selection.getRanges() );\n\n\t\tif ( !range.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( batch.type == 'transparent' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst changes = Array.from( editor.model.document.differ.getChanges() );\n\t\tconst entry = changes[ 0 ];\n\n\t\t// Typing is represented by only a single change.\n\t\tif ( changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst blockToFormat = entry.position.parent;\n\n\t\t// Block formatting should be disabled in codeBlocks (#5800).\n\t\tif ( blockToFormat.is( 'element', 'codeBlock' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only list commands and custom callbacks can be applied inside a list.\n\t\tif ( blockToFormat.is( 'element', 'listItem' ) &&\n\t\t\ttypeof callbackOrCommand !== 'function' &&\n\t\t\t![ 'numberedList', 'bulletedList', 'todoList' ].includes( callbackOrCommand )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// In case a command is bound, do not re-execute it over an existing block style which would result with a style removal.\n\t\t// Instead just drop processing so that autoformat trigger text is not lost. E.g. writing \"# \" in a level 1 heading.\n\t\tif ( command && command.value === true ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstNode = blockToFormat.getChild( 0 );\n\t\tconst firstNodeRange = editor.model.createRangeOn( firstNode );\n\n\t\t// Range is only expected to be within or at the very end of the first text node.\n\t\tif ( !firstNodeRange.containsRange( range ) && !range.end.isEqual( firstNodeRange.end ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst match = pattern.exec( firstNode.data.substr( 0, range.end.offset ) );\n\n\t\t// ...and this text node's data match the pattern.\n\t\tif ( !match ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n\t\teditor.model.enqueueChange( writer => {\n\t\t\t// Matched range.\n\t\t\tconst start = writer.createPositionAt( blockToFormat, 0 );\n\t\t\tconst end = writer.createPositionAt( blockToFormat, match[ 0 ].length );\n\t\t\tconst range = new LiveRange( start, end );\n\n\t\t\tconst wasChanged = callback( { match } );\n\n\t\t\t// Remove matched text.\n\t\t\tif ( wasChanged !== false ) {\n\t\t\t\twriter.remove( range );\n\n\t\t\t\tconst selectionRange = editor.model.document.selection.getFirstRange();\n\t\t\t\tconst blockRange = writer.createRangeIn( blockToFormat );\n\n\t\t\t\t// If the block is empty and the document selection has been moved when\n\t\t\t\t// applying formatting (e.g. is now in newly created block).\n\t\t\t\tif ( blockToFormat.isEmpty && !blockRange.isEqual( selectionRange ) && !blockRange.containsRange( selectionRange, true ) ) {\n\t\t\t\t\twriter.remove( blockToFormat );\n\t\t\t\t}\n\t\t\t}\n\t\t\trange.detach();\n\n\t\t\teditor.model.enqueueChange( () => {\n\t\t\t\teditor.plugins.get( 'Delete' ).requestUndoOnBackspace();\n\t\t\t} );\n\t\t} );\n\t} );\n}\n"]},"metadata":{},"sourceType":"module"}